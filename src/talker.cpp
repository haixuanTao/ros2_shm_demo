// Copyright 2021 Apex.AI, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <chrono>
#include <cstring>
#include <memory>
#include <string>
#include <utility>
#include <random>
#include "rclcpp/rclcpp.hpp"
#include <chrono>

#include "ros2_shm_demo/msg/shm_topic.hpp"

using namespace std::chrono_literals;

class Talker : public rclcpp::Node
{
private:
    using Topic = ros2_shm_demo::msg::ShmTopic;

public:
    explicit Talker(const rclcpp::NodeOptions &options)
        : Node("shm_demo_talker", options)
    {

        auto publishMessage = [this]() -> void
        {
            auto loanedMsg = m_publisher->borrow_loaned_message();

            populateLoanedMessage(loanedMsg);

            m_publisher->publish(std::move(loanedMsg));
            // We gave up ownership and loanedMsg is not supposed to be accessed
            // anymore

            m_count++;
        };

        rclcpp::QoS qos(rclcpp::KeepLast(10));
        m_publisher = this->create_publisher<Topic>("chatter", qos);

        // Use a timer to schedule periodic message publishing.
        m_timer = this->create_wall_timer(100ms, publishMessage);
    }

private:
    uint64_t m_count = 1;
    rclcpp::Publisher<Topic>::SharedPtr m_publisher;
    rclcpp::TimerBase::SharedPtr m_timer;

    void populateLoanedMessage(rclcpp::LoanedMessage<Topic> &loanedMsg)
    {
        Topic &msg = loanedMsg.get();
        // Start the timer
        int myArray[] = {8};
        const int size = myArray[m_count / 100];

        // Generate a random byte array
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> dis(0, 255);

        unsigned char *randomBytes = new unsigned char[size];

        for (int i = 0; i < size; ++i)
        {
            randomBytes[i] = static_cast<unsigned char>(dis(gen));
        }

        // Convert the start time to a byte array
        auto start = std::chrono::high_resolution_clock::now();
        const void *startPtr = static_cast<const void *>(&start);
        const unsigned char *startBytes = static_cast<const unsigned char *>(startPtr);
        const int arraySize = sizeof(start);
        // Copy the start byte representation into the random byte array
        std::memcpy(randomBytes, startBytes, arraySize);

        // Note that msg.data is a std::array generated by the IDL compiler
        std::memcpy(msg.data.data(), randomBytes, size);
    }
};

int main(int argc, char *argv[])
{
    rclcpp::init(argc, argv);
    rclcpp::NodeOptions options;
    rclcpp::spin(std::make_shared<Talker>(options));
    rclcpp::shutdown();

    return 0;
}